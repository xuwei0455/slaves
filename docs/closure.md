## Closure in go

忘了在哪看到过说golang的闭包有些奇怪，容易把自己绕进去，在写这个库的时候，我也一不小心
踩进去了，这里记录下。

具体的问题如下：

``` go
result := 0

w := New()
for _, n := range []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
    w.Add(func() {
        result += n
    })
}
w.Join()

fmt.Println(n)
```

有一段代码如上，按我的想法, 这里每次传入的闭包所包含的变量`n`都是新的，所以11次循环，
每次循环都有一个新的变量`n`，这样最后的结果就是55。

但实际上，这里闭包保留着的是对`n`的引用，而不是新建一个变量，那就比较尴尬了，所以n的
值就是一个玄学了，取决于每一个goroutine启动的时候`n`是什么值。

解决问题的办法也很简单，那就是单独为每一个闭包新建一个变量：

``` go
result := 0

w := New()
for _, n := range []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
    w.Add(func() {
        i := n
        result += i
    })
}
w.Join()

fmt.Println(n)
```
这样看起来貌似可以的样子，但实际上并不对，因为闭包并不是立即执行的，具体的执行时间
是闭包被调用的时候，那这个其实跟第一个例子并没有区别，使用`n`的时候才能确定`n`的
取值。

那要把新建变量的事情再提前，那就是如下：
``` go
result := 0

w := New()
for _, n := range []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
    i := n
    w.Add(func() {
        result += i
    })
}
w.Join()

fmt.Println(n)
```

每次循环都新建一个变量`i`，这样闭包引用的都是一个新的变量，11个闭包引用了11个不同的
变量，这个可以通过fmt.Println(&i)来查看变量的地址来证实确实是不同的变量。

既然`i`可以赋值多次，每次都新建一个变量，那么直接对`n`赋值行不行呢？答案是可以的：

``` go
result := 0

w := New()
for _, n := range []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
    n := n
    w.Add(func() {
        result += n
    })
}
w.Join()

fmt.Println(n)
```

不过，这个赋值总看起来怪怪的，对于不明白这段故事的人来说，这个有点难以理解，那么有
没有更清楚的，更好的写法呢？有的：

``` go
result := 0

for _, n := range []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
    go func(n int) {
        result += n
    }(n)
}

fmt.Println(result)
```
这里虽然解决了变量赋值的可读性问题（通过函数传参，新建了一个函数内部使用的局部变量），
但是问题是，这样传参相当于运行了这个闭包，所以只能用关键字`go`来运行了。

另外，[官方文档](https://golang.org/doc/faq#closures_and_goroutines)上有关于
这个问题的解释。

